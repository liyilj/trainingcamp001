# 滑动窗口

## 定义

滑动窗口是一种想象出来的数据结构：

滑动窗口有左边界L和右边界R

在数组或者字符串或者一个序列上，记为S，窗口就是S[L..R]这一部分

L往右滑意味着一个样本出了窗口，R往右滑意味着一个样本进了窗口

L和R都只能往右滑

> 不要出现L>R的情况
>
> 任何时候都不要让L--或者R--
>
> ##### 滑动窗口的含义：当处于一种窗口状况下，锁定R，滑动L时，窗口内的数据表示依次成为最大值的优先级
>
> ##### 滑动R时，相等的时候以下标晚过期的值为大
>
> ##### 如果双端队列中只能放一个值的话，放下标，不要放值；存下标是为了判断过期的



> #### 优化问题的方向
>
> 1. 数据状况
> 2. 把范围和问题本身建立单调性
>
> ##### 窗口滑动法和收尾指针法是常见的针对范围上有单调性的问题的求解方法！！！！



# 单调栈

## 定义

一种特别设计的栈结构，为了解决如下的问题：

给定一个可能含有重复值的数组arr，i位置的数一定存在如下两个信息

1. arr[i]的左侧离i最近并且小于(或者大于) arr[i]的数在哪？
2. arr[i]的右侧离i最近并且小于(或者大于) arr[i]的数在哪？

> ##### 如果存在相等的情况，在单调栈中存在index组成的list



# 滑动窗口、单调栈怎么用？

想用滑动窗口，要想办法把具体的问题转化为滑动窗口的处理流程

想用滑动窗口最值的更新结构，就看看处理流程下，是否需要最值这个信息

想用单调栈，要想办法把具体的问题转化为单调栈所解决的原问题

滑动窗口及其最大值和最小值的更新结构、单调栈都是重要算法原型。



# 类似斐波那契数列的递归

求斐波那契数列矩阵乘法的方法

1. 斐波那契数列的线性求解（O(N)）的方式非常好理解

2. 同时利用线性代数，也可以改写出另一种表示

   |F(N), F(N-1)| = |F(2), F(1)| * 某个二阶矩阵的N-2次方

3. 求出这个二阶矩阵，进而最快求出这个二阶矩阵的N-2次方

> 斐波那契数列求解可以优化成O(logN)

> ##### 斐波那契数列的适用范围：斐波那契数列的推广，没有条件转移的递推公式

> ##### 如果某个递归，除了初始项之外，具有如下的形式
>
> ##### F(N) = C1 * F(N) + C2 * F(N-1) + … + Ck * F(N-k) ( C1…Ck 和k都是常数)
>
> ##### 并且这个递归的表达式是严格的、不随条件转移的
>
> ##### 那么都存在类似斐波那契数列的优化，时间复杂度都能优化成O(logN)



# 蓄水池算法

解决的问题：

假设有一个源源不断吐出不同球的机器，只有装下10个球的袋子，每一个吐出的球，要么放入袋子，要么永远扔掉

如何做到机器吐出每一个球之后，所有吐出的球都等概率被放进袋子里



# KMP算法

假设字符串str长度为N，字符串match长度为M， M <= N

想确定str中是否有某个子串是等于match的。

时间复杂度O(N)

## KMP算法核心

1. 如何理解next数组
2. 如何利用next数组加速匹配过程，优化时的两个实质！



> ##### 二叉树的先序序列化是没有歧义的！！！



# bfprt算法

在无序数组中求第K小的数，怎么样O(N)实现

1. 改写快排的方法
2. bfprt算法

> ##### bfprt算法和快排方式的区别就是挑选partition的方式由精挑细选取代随机



# Manacher算法

假设字符串str长度为N，想返回最长回文子串的长度

时间复杂度O(N)

> Manacher算法核心
>
> 1. 理解回文半径数组
> 2. 理解所有中心的回文最右边界R，和取得R时的中心点C
> 3. 理解 L···(i’)···C···(i)···R 的结构，以及根据i‘回文长度进行的状况划分
> 4. 每一种情况划分，都可以加速求解i回文半径的过程